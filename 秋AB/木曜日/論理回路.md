# 論理回路

## 2017-10-12

### 授業メタ
- 本講義での前提
    - 電圧レベル High = 1, Low = 0
    - 特に指定しない場合、
        - 入力信号: A, B, C, ...
        - 出力信号: Z, Y, X, ...
    - 信号線は何本か集めて数を表すこととし、その線に C, B, A という名前がある場合、一番下の桁はAとする

### 回路設計
- 要求 → 使用の記述 → 回路の導出 → 回路の簡単化

### 加法標準形
- 真理値表から論理回路を設計する1つの手法
- 出力が1である行を積項とし、この積項の論理和を求める。求めたブール代数式が加法標準形となる。
- 加法標準形から AND と OR を用いて回路を導出する
- 例: 3入力の多数決回路 [図1]

### 加法標準形の変形テクニック
- 出力に1が多いとき
    - 出力が0である行を積項とし、この積項の否定論理和を求めればよい( not(f) で式を表し、その否定より f と求める) 
    - 例: [図2]

### 加法標準形による回路設計法
- 利点
    - 簡単かつ機械的に設計できる
- 欠点
    - 回路にムダが多すぎる
        - 真理値表の出力における1の数(あるいは0の数)だけANDが必要
        - すべてのANDの入力数が入力信号の数だけ必要
        - ANDの数と同数の入力を持つORが必要
- **→ 回路の簡単化が必要**

### カルノー図による簡単化
- カルノー図
    - 縦横に入力パターンを記述し、出力を書き込む
    - 1を(幅及び高さが1, 2, 4の)ループで囲む
    - ループに対応する積項(ANDゲート)の論理和(ORゲート)を求めて、回路を簡単化する
    - 例: [図3]

### カルノー図の注意点
- 入力パターンの並びに注意
    - グレイコードを用いる
        - グレイコード: 隣同士が1ビットだけ違う
    - 例: 00 → 01 → 11 → 10
- 複数の回答があり得る
- できるだけ大きく囲む
    - 積項の数を減らすため
- ループの数を減らす
    - 積項の数を減らすため
- 上下左右はつながっている
- 重複して囲んでもよい
- 例: [図4]

### don't care の扱い
- 回路を簡単化するために、カルノー図では "-" あるいは "*" で表し、1として扱ってよい

### カルノー図の簡単化テクニック
- 否定関数 not(f) を用いる
- 排他的論理和を用いる [図5]
    - ただし、使用可能ながゲートやその入力数・出力数に関する制約を満足する必要がある

### カルノー図の限界
- カルノー図は、入力数が5以上の場合は扱いづらくなり、入力数が7以上は手に負えない
- 複数の出力にまたがる共通部をまとめるようなことはできない

### ブール代数による簡単化
- ブール代数の公理と定理を活用する
- 例
    - AA + AB + AC + BC = A(A + B + C) + BC = A + BC

---
## 2017-10-05

### デジタル回路とは
* デジタル(digital)
    * ラテン語 digitus = 指 -> 指で数えられるもの
    * 離散的な値 <-> アナログ: 連続的な量
* ディジタル回路
    * 0と1の3種類の値のみを使用する
    * 回路上では、0と1はそれぞれ電圧が低い(low)と高い(high)に対応する

### 2種類の回路
* 組み合わせ回路
    * 入力のみによって出力が決まる
    * 授業前半の内容
* 順序回路
    * 内部に状態を持ち、入力と内部状態によって出力が決まる
    * 内部状態はクロックのタイミングで変化
    * 授業後半でやる内容

### 数の表し方
* 2進数
    * 0と1のみで数を表現 -> 1桁を0と1のみで表現
    * 1桁分を1bitと呼ぶ
    * 回路上では信号線1本が1bitに対応

### 2進数から10進数に変換
* 2進数の各桁の重みは右端かあｒ1, 2, 4, 8, ...
* 例: 11001(2) = 16 + 8 + 0 + 0 + 1 = 25

### bit数と表せる数
* n bit により表せる数は 2^n 個である

### 組み合わせ回路
* N bit の入力に対して M bit の出力を決定する関数
* [図1]
    * Om = f(I1, I2, I3, ..., IN)
    * fは論理演算により実現する
    * 一般に I1, I2, I3, ..., IN には A, B, ..., O1, O2, ..., OM には Z, Y, X, ... を用いることが多い

### 基本的な論理演算とその表現方法
* 論理積(AND)
    * ブール大数式 Y=A・B あるいは単に AB
    * 真理値表 [図2]
    * ゲート(MIL = Military Standard Specification 記号) [図3]
* 論理和(OR)
    * ブール代数式 Y = A + B
    * 真理値表 [図4]
    * ゲート記号 [図5]
* 否定(NOT)
    * ブール代数式 Y = A(トップバー)
    * 真理値表 [図6]
    * ゲート記号 [図7]
        * バッファ: 論理上は無意味。信号レベルを維持したり、信号を遅延させるために使われる。
* 否定論理積(NAND)
    * ブール代数式 Y = AB(トップバー)
    * 真理値表 [図8]
    * ゲート記号 [図9]
* 否定論理和
    * ブール代数式 Y = A + B (トップバー)
    * 真理値表 [図10]
    * ゲート記号 [図11]

### 2入力の組み合わせ回路 
* 00 ~ 11 の4つの入力パターン
* 2^4 = 16 通りの回路(関数)
* AND, OR, NOT, NAND, NOR, 他にも...
    * 排他的論理和(XOR)
        * 真理値表 [図12]
        * ゲート記号 [図13]
<br>
<br>
<br>

---

## 2017-10-19
### いろいろな組み合わせ回路
* 基本的には前回までの設計法により実現できる。
    * 真理値表 → 簡単化した回路
* 具体的な回路は、単に入出力信号が増えるだけと捉えられる。
    * 例: 炎山カイロ、セレクタ、コンパレータ、パリティ

### 加算器
* 1ビット加算器(2 in 2 out)
    * 真理値表の行数 2^2 = 4

    |A|B|C|S|
    |:-:|:-:|:-:|:-:|
    |0|0|0|0|
    |0|1|0|1|
    |1|0|0|1|
    |1|1|1|0|

* 8ビット加算器
    * 行数: 2^16 = 65536
* nビット加算器
    * 行数: 2^n
* **加法標準形による設計法をそのまま適用することは現実的ではない**

### 分割方式による閑散期の実現
* 1(あるいは2とか4)ビットの加算器を組み合わせてnビットの加算器を実現する
* 1ビットの加算器[図1]
* 1ビットの全加算器[図2]
* 1ビットフルアダーによる4ビット加算器[図3]
    * リープルキャリ方式と呼ばれる
    * 桁上げ信号が出力されるまでに4段のフルアダーを信号が通過する伝搬遅延が生じる
        * nビット加算器を構成する場合、伝搬遅延の増大を防ぐためには桁上げを先見すればよい
* 1ビットフルアダーと先見回路による4ビット加算器[図4]
    * キャリールックアヘッド方式と呼ばれる
    * リプルキャリー方式と比べ、伝搬遅延が小さくなる。一方で、回路規模は大きくなる。
    * 先見回路は簡単化を含む回路設計により導出すればよい

### 減算器
* 加算器と同様に、真理値表から1ビット減算器を作成し、それを組み合わせて実現することはできる。
    * しかし、実現した回路は当然減算しかできない。
    * **負の数を表すことができれば、加算器にも使うことができる。**

#### 2の補数
* 2進数による負の数を実現するために用いられる方法
    * 求め方: まず、1の補数(ビット反転)を求める。次に、その結果に1を加える。
    * 最上位ビットが符号を表す